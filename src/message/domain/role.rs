//! Message role types defining the source of a message in a conversation.

use serde::{Deserialize, Serialize};
use std::fmt;

/// Error returned when parsing an invalid role string.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ParseRoleError(String);

impl fmt::Display for ParseRoleError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "invalid role: '{}'", self.0)
    }
}

impl std::error::Error for ParseRoleError {}

/// The role of a message participant in a conversation.
///
/// Corbusier uses four roles to classify message sources, enabling consistent
/// handling across different agent backends.
///
/// # Examples
///
/// ```
/// use corbusier::message::domain::Role;
///
/// let role = Role::Assistant;
/// assert!(role.can_call_tools());
/// assert!(!role.is_human());
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Role {
    /// A message from a human user.
    User,
    /// A message generated by an AI assistant.
    Assistant,
    /// A message containing tool execution results.
    Tool,
    /// A system-level message (prompts, context, instructions).
    System,
}

impl fmt::Display for Role {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.as_str())
    }
}

impl Role {
    /// Returns the string representation of this role.
    ///
    /// This matches the serialized form used in database storage.
    #[must_use]
    pub const fn as_str(&self) -> &'static str {
        match self {
            Self::User => "user",
            Self::Assistant => "assistant",
            Self::Tool => "tool",
            Self::System => "system",
        }
    }

    /// Returns `true` if this role can initiate tool calls.
    ///
    /// Only assistant messages may contain tool call requests.
    #[must_use]
    pub const fn can_call_tools(&self) -> bool {
        matches!(self, Self::Assistant)
    }

    /// Returns `true` if this role represents a human participant.
    #[must_use]
    pub const fn is_human(&self) -> bool {
        matches!(self, Self::User)
    }

    /// Returns `true` if this role represents system-level content.
    #[must_use]
    pub const fn is_system(&self) -> bool {
        matches!(self, Self::System)
    }

    /// Returns `true` if this role represents tool output.
    #[must_use]
    pub const fn is_tool(&self) -> bool {
        matches!(self, Self::Tool)
    }
}

/// Parses a role from its string representation.
///
/// The conversion is **case-sensitive** and only accepts the exact lowercase
/// strings: `"user"`, `"assistant"`, `"tool"`, and `"system"`.
///
/// # Examples
///
/// ```
/// use corbusier::message::domain::Role;
///
/// assert!(Role::try_from("user").is_ok());
/// assert!(Role::try_from("User").is_err()); // Case-sensitive
/// assert!(Role::try_from("USER").is_err());
/// ```
impl TryFrom<&str> for Role {
    type Error = ParseRoleError;

    fn try_from(s: &str) -> Result<Self, Self::Error> {
        match s {
            "user" => Ok(Self::User),
            "assistant" => Ok(Self::Assistant),
            "tool" => Ok(Self::Tool),
            "system" => Ok(Self::System),
            _ => Err(ParseRoleError(s.to_owned())),
        }
    }
}
